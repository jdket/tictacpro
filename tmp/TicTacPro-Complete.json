{
  "name": "TicTacPro",
  "description": "Enhanced 5x5 Tic-Tac-Toe with 24 effects and 9 obstacles",
  "version": "1.0.0",
  "type": "standalone-game",
  
  "html": "<!DOCTYPE html><html lang='en'><head><meta charset='UTF-8'><meta name='viewport' content='width=device-width, initial-scale=1.0'><title>TicTacPro</title><style>GAME_CSS_PLACEHOLDER</style></head><body><div id='app'></div><script>GAME_JS_PLACEHOLDER</script></body></html>",

  "css": "* { margin: 0; padding: 0; box-sizing: border-box; } body { font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; display: flex; justify-content: center; align-items: center; color: #333; } .app { max-width: 1200px; width: 100%; padding: 20px; } .menu-screen, .level-preview-screen, .level-complete-screen { text-align: center; background: rgba(255, 255, 255, 0.1); backdrop-filter: blur(10px); border-radius: 20px; padding: 40px; border: 1px solid rgba(255, 255, 255, 0.2); } .menu-screen h1 { font-size: 48px; color: #fff; margin-bottom: 20px; text-shadow: 0 4px 20px rgba(0,0,0,0.3); } .menu-screen p { font-size: 18px; color: rgba(255, 255, 255, 0.8); margin-bottom: 40px; } .start-button, .next-level-button { background: linear-gradient(45deg, #ff6b6b, #ff8e53); border: none; color: white; font-size: 18px; font-weight: bold; padding: 15px 30px; border-radius: 25px; cursor: pointer; transition: all 0.3s ease; box-shadow: 0 4px 15px rgba(255, 107, 107, 0.4); } .start-button:hover, .next-level-button:hover { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(255, 107, 107, 0.6); } .game-area { display: flex; flex-direction: column; gap: 30px; } .game-layout { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 20px; align-items: center; margin-bottom: 20px; } .level-display { background: rgba(255, 255, 255, 0.1); backdrop-filter: blur(10px); border-radius: 15px; padding: 20px; border: 1px solid rgba(255, 255, 255, 0.2); text-align: center; } .level-number { font-size: 32px; font-weight: bold; color: #fff; } .score-display { display: flex; justify-content: center; gap: 40px; background: rgba(255, 255, 255, 0.1); backdrop-filter: blur(10px); border-radius: 15px; padding: 20px; border: 1px solid rgba(255, 255, 255, 0.2); } .score-section { text-align: center; } .score-label { font-size: 12px; color: rgba(255, 255, 255, 0.8); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 5px; } .score-value { font-size: 24px; font-weight: bold; color: #fff; } .board-container { display: flex; justify-content: center; } .game-board { display: grid; grid-template-columns: repeat(5, 1fr); gap: 8px; background: rgba(255, 255, 255, 0.1); backdrop-filter: blur(10px); border-radius: 20px; padding: 20px; border: 1px solid rgba(255, 255, 255, 0.2); } .cell { width: 80px; height: 80px; background: rgba(255, 255, 255, 0.2); border: 2px solid rgba(255, 255, 255, 0.3); border-radius: 12px; display: flex; justify-content: center; align-items: center; font-size: 32px; font-weight: bold; cursor: pointer; transition: all 0.2s ease; position: relative; } .cell:hover { background: rgba(255, 255, 255, 0.3); transform: scale(1.05); } .cell.disabled { cursor: not-allowed; opacity: 0.5; } .cell.dimmed { background: rgba(100, 100, 100, 0.4); } .cell.wild { background: rgba(255, 215, 0, 0.3); border-color: #ffd700; } .cell.winning { background: rgba(0, 255, 136, 0.4); border-color: #00ff88; animation: pulse 1s infinite; } .effects-preview { display: flex; flex-direction: column; gap: 15px; margin: 30px 0; } .effect-preview { background: rgba(255, 255, 255, 0.1); backdrop-filter: blur(10px); border-radius: 12px; padding: 15px; border: 1px solid rgba(255, 255, 255, 0.2); text-align: left; } .effect-preview.good-effect { border-left: 4px solid #00ff88; } .effect-preview.bad-effect { border-left: 4px solid #ff6b6b; } .effect-preview h3 { font-size: 16px; color: #fff; margin-bottom: 8px; } .effect-preview p { font-size: 14px; color: rgba(255, 255, 255, 0.8); } .sound-buttons { position: fixed; top: 20px; right: 20px; z-index: 50; display: flex; gap: 10px; } .sound-button { background: rgba(255, 255, 255, 0.9); border: 1px solid rgba(0, 0, 0, 0.1); border-radius: 8px; padding: 8px; cursor: pointer; transition: all 0.2s ease; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1); } .sound-button:hover { background: rgba(255, 255, 255, 1); } @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }",

  "gameData": {
    "effects": [
      { "id":"e001","name":"Center Boost","type":"scoring","text":"Scoring through center gives +3000 pts","value":3000 },
      { "id":"e002","name":"Corner Bonus","type":"scoring","text":"+2000 pts per corner in your scoring line","value":2000 },
      { "id":"e003","name":"Edge Bonus","type":"scoring","text":"+1000 pts per edge in your scoring line","value":1000 },
      { "id":"e004","name":"Combo Counter","type":"scoring","text":"Each additional scoring line after the first gives +1000 pts","value":1000 },
      { "id":"e005","name":"Diagonal Bonus","type":"scoring","text":"Any diagonal scoring line gives +2000 pts","value":2000 },
      { "id":"e006","name":"Row Runner","type":"scoring","text":"Any horizontal scoring line gives +2000 pts","value":2000 },
      { "id":"e007","name":"Column Climber","type":"scoring","text":"Any vertical scoring line gives +2000 pts","value":2000 },
      { "id":"e008","name":"Triple Cherry","type":"scoring","text":"If you score 3+ lines this level, +3000 at end","value":3000 },
      { "id":"e009","name":"Quick Start","type":"scoring","text":"First move on center tile gives +2000 pts","value":2000 },
      { "id":"e010","name":"Fast Corner","type":"scoring","text":"Corner placement that completes scoring line gives +1000 pts","value":1000 },
      { "id":"e011","name":"Line Streak","type":"scoring","text":"Scoring on two consecutive turns gives +2000 pts","value":2000 },
      { "id":"e012","name":"Middle Master","type":"scoring","text":"Scoring line fully on middle row or column gives +2000 pts","value":2000 },
      { "id":"e013","name":"Two Line Gift","type":"scoring","text":"Exactly 2 lines this level, +2000 pts","value":2000 },
      { "id":"e014","name":"Corner Collector","type":"scoring","text":"All 4 corners marked by level end, +3000 pts","value":3000 },
      { "id":"e015","name":"Top Focus","type":"scoring","text":"Scoring line fully in top two rows, +1000 pts","value":1000 },
      { "id":"e016","name":"Bottom Focus","type":"scoring","text":"Scoring line fully in bottom two rows, +1000 pts","value":1000 },
      { "id":"e017","name":"Memory Challenge","type":"memory","text":"Dim 5 tiles, Dimmed tiles give double score","value":2 },
      { "id":"e018","name":"Corner Memory","type":"memory","text":"Dim all 4 corners, Dimmed corner in scoring line gives +2000 pts","value":2000 },
      { "id":"e019","name":"Edge Memory","type":"memory","text":"Dim 4 edges, Dimmed edge in scoring line gives +1000 pts","value":1000 },
      { "id":"e020","name":"Wild Favor","type":"wild","text":"5 tiles become Wild, Wild tiles in scoring line give double score","value":2 },
      { "id":"e021","name":"Wild Corners","type":"wild","text":"2 corners become Wild, Wild corner in line gives +2000 pts","value":2000 },
      { "id":"e022","name":"Wild Edges","type":"wild","text":"3 edges become Wild, Wild edge in line gives +1000 pts","value":1000 },
      { "id":"e023","name":"Wild Collector","type":"wild","text":"3 tiles become Wild, use all 3 in different scoring lines for +3000 pts","value":3000 },
      { "id":"e024","name":"Wild Saver","type":"wild","text":"2 tiles become Wild, avoid Wild tiles all level for +2000 pts","value":2000 }
    ],
    "obstacles": [
      { "id":"o001","name":"Memory Drain","text":"Dim 5 tiles, Dimmed tiles give Opponent double score","rule":"dims 5 tiles, opponent benefits" },
      { "id":"o002","name":"Wild Drain","text":"5 tiles become Wild, Wild tiles in your scoring line give Opponent double score","rule":"5 wilds benefit opponent" },
      { "id":"o003","name":"Dim Penalty","text":"Dim 2 tiles, any scoring line next to Dimmed tiles loses 1000 pts","rule":"penalty for adjacent to dimmed" },
      { "id":"o004","name":"Wild Trap","text":"2 tiles become Wild, any scoring line next to Wild tiles loses 1000 pts","rule":"penalty for adjacent to wild" },
      { "id":"o005","name":"Dim Flood","text":"Dim 8 tiles at random","rule":"dims 8 random tiles" },
      { "id":"o006","name":"Wild Penalty","text":"5 tiles become Wild, Wild tiles in your line subtract 1000 pts","rule":"wild tiles subtract points" },
      { "id":"o007","name":"Edge Tax","text":"Any scoring line using at least one edge subtracts 1000 pts","rule":"edge penalty" },
      { "id":"o008","name":"Corner Tax","text":"Any scoring line using at least one corner subtracts 1000 pts","rule":"corner penalty" },
      { "id":"o009","name":"Center Tax","text":"Any scoring line using center subtracts 2000 pts","rule":"center penalty" }
    ]
  },

  "javascript": "class TicTacPro { constructor() { this.gameState = { phase: 'menu', currentLevel: 1, score: 0, opponentScore: 0, board: Array(25).fill(null), currentEffect: null, currentObstacle: null, nextLevelEffects: [], nextLevelObstacles: [], showLevelPreview: false, winningLine: null, dimmedCells: [], wildCells: [], linesCompleted: 0, streakCount: 0, firstMoveWasCenter: false }; this.gameData = GAME_DATA_PLACEHOLDER; this.isMuted = false; this.isMusicMuted = false; this.setupAudio(); this.render(); } setupAudio() { this.clickSound = new Audio('data:audio/mp3;base64,SUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU4Ljc2LjEwMAAAAAAAAAAAAAAA//uQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASW5mbwAAAA8AAAAZAAAqcgATExMdHR0dJycnJzExMTE7Ozs7RERERE5OTk5YWFhYYmJiYmxsbGx2dnZ2gICAgImJiYmTk5OTnZ2dnaenp6exsbGxu7u7u8TExMTOzs7O2NjY2OLi4uLs7Ozs9vb29v////8AAAAATGF2ZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKnKO+E5w//uSZLYDBKFiw6sJM3ImwAicBGEAEoWfDrWUgAirgCCihgAA/f/pR9itnkm9VmjG6tJlN1WGNmZ0JjPR6HI1GsZhCexN6VPvGvZWBg8tTHQjThQfvlUQRhMZo+fl43efwFSlbaP5IIopXjBLi4QxLLb9x9Yd10EyqKBheK/SYduMTWHbdIdY8y/KMzLXK+cu/jnF4YXIyxr6w+Vye+ZlsswrY3qvy/+ZrodyWfHpPOQzDso+xh+ef/1Y7j22WSmLxiGIcsP9Dcvd18KWtJc+/Y3/8zw449PD7aSu3JFyNMjbW61WzutTa3S1bP/qxl+e6e3v8M+v3/M2uOQ/EXuQ4ut/4vQuXumtYctaq4Z5VcAF//mv/8OgBIMAAAAAIwa4'); this.clickSound.volume = 0.5; } playClick() { if (!this.isMuted) { const soundClone = this.clickSound.cloneNode(); soundClone.play().catch(e => console.log('Sound play prevented')); } } getRandomEffect() { const effects = this.gameData.effects.filter(e => ['scoring', 'memory', 'wild'].includes(e.type)); return effects[Math.floor(Math.random() * effects.length)]; } getRandomObstacle() { return this.gameData.obstacles[Math.floor(Math.random() * this.gameData.obstacles.length)]; } getEffectsForLevel(level) { return [this.getRandomEffect()]; } getObstaclesForLevel(level) { return level % 2 === 0 ? [this.getRandomObstacle()] : []; } checkWinningLine(board, player, wildCells = []) { const lines = [ [0,1,2,3], [1,2,3,4], [5,6,7,8], [6,7,8,9], [10,11,12,13], [11,12,13,14], [15,16,17,18], [16,17,18,19], [20,21,22,23], [21,22,23,24], [0,5,10,15], [5,10,15,20], [1,6,11,16], [6,11,16,21], [2,7,12,17], [7,12,17,22], [3,8,13,18], [8,13,18,23], [4,9,14,19], [9,14,19,24], [0,6,12,18], [6,12,18,24], [1,7,13,19], [2,8,14,20], [4,8,12,16], [3,7,11,15], [8,12,16,20] ]; for (let line of lines) { let playerCount = 0; for (let pos of line) { if (board[pos] === player || wildCells.includes(pos)) { playerCount++; } } if (playerCount >= 4) return line; } return null; } checkNewWinningLines(board, player, lastMove, wildCells = []) { const lines = [ [0,1,2,3], [1,2,3,4], [5,6,7,8], [6,7,8,9], [10,11,12,13], [11,12,13,14], [15,16,17,18], [16,17,18,19], [20,21,22,23], [21,22,23,24], [0,5,10,15], [5,10,15,20], [1,6,11,16], [6,11,16,21], [2,7,12,17], [7,12,17,22], [3,8,13,18], [8,13,18,23], [4,9,14,19], [9,14,19,24], [0,6,12,18], [6,12,18,24], [1,7,13,19], [2,8,14,20], [4,8,12,16], [3,7,11,15], [8,12,16,20] ]; const newLines = []; for (let line of lines) { if (!line.includes(lastMove)) continue; let playerCount = 0; for (let pos of line) { if (board[pos] === player || wildCells.includes(pos)) { playerCount++; } } if (playerCount >= 4) newLines.push(line); } return newLines; } isBoardFull(board, wildCells = []) { for (let i = 0; i < 25; i++) { if (board[i] === null && !wildCells.includes(i)) return false; } return true; } getEmptyCells(board, wildCells = []) { const empty = []; for (let i = 0; i < 25; i++) { if (board[i] === null && !wildCells.includes(i)) empty.push(i); } return empty; } processEffect(cellIndex, line) { const effect = this.gameState.currentEffect; if (!effect) return 0; let bonus = 0; const corners = [0, 4, 20, 24]; const edges = [1, 2, 3, 5, 9, 10, 14, 15, 19, 21, 22, 23]; const center = 12; switch (effect.id) { case 'e001': if (line && line.includes(center)) bonus += 3000; break; case 'e002': if (line) bonus += line.filter(pos => corners.includes(pos)).length * 2000; break; case 'e003': if (line) bonus += line.filter(pos => edges.includes(pos)).length * 1000; break; case 'e004': if (this.gameState.linesCompleted > 0) bonus += 1000; break; case 'e005': if (line && this.isDiagonal(line)) bonus += 2000; break; case 'e006': if (line && this.isHorizontal(line)) bonus += 2000; break; case 'e007': if (line && this.isVertical(line)) bonus += 2000; break; case 'e009': if (cellIndex === center && this.gameState.board.every(cell => cell === null)) bonus += 2000; break; case 'e010': if (line && corners.includes(cellIndex)) bonus += 1000; break; case 'e011': if (this.gameState.streakCount >= 2) bonus += 2000; break; } return bonus; } isDiagonal(line) { const diagonals = [[0,6,12,18], [6,12,18,24], [1,7,13,19], [2,8,14,20], [4,8,12,16], [3,7,11,15], [8,12,16,20]]; return diagonals.some(diag => diag.every(pos => line.includes(pos))); } isHorizontal(line) { const horizontals = [[0,1,2,3], [1,2,3,4], [5,6,7,8], [6,7,8,9], [10,11,12,13], [11,12,13,14], [15,16,17,18], [16,17,18,19], [20,21,22,23], [21,22,23,24]]; return horizontals.some(horiz => horiz.every(pos => line.includes(pos))); } isVertical(line) { const verticals = [[0,5,10,15], [5,10,15,20], [1,6,11,16], [6,11,16,21], [2,7,12,17], [7,12,17,22], [3,8,13,18], [8,13,18,23], [4,9,14,19], [9,14,19,24]]; return verticals.some(vert => vert.every(pos => line.includes(pos))); } initializeEffect() { const effect = this.gameState.currentEffect; if (!effect) return; switch (effect.id) { case 'e017': case 'e018': case 'e019': const dimCount = effect.id === 'e017' ? 5 : effect.id === 'e018' ? 4 : 4; const availableCells = Array.from({length: 25}, (_, i) => i); for (let i = 0; i < dimCount && availableCells.length > 0; i++) { const randomIndex = Math.floor(Math.random() * availableCells.length); this.gameState.dimmedCells.push(availableCells.splice(randomIndex, 1)[0]); } break; case 'e020': case 'e021': case 'e022': case 'e023': case 'e024': const wildCount = effect.id === 'e020' ? 5 : effect.id === 'e021' ? 2 : effect.id === 'e022' ? 3 : effect.id === 'e023' ? 3 : 2; const availableWildCells = Array.from({length: 25}, (_, i) => i); for (let i = 0; i < wildCount && availableWildCells.length > 0; i++) { const randomIndex = Math.floor(Math.random() * availableWildCells.length); this.gameState.wildCells.push(availableWildCells.splice(randomIndex, 1)[0]); } break; } } startGame() { if (this.gameState.currentLevel === 1 && !this.gameState.showLevelPreview) { const effects = this.getEffectsForLevel(1); const obstacles = this.getObstaclesForLevel(1); this.gameState.nextLevelEffects = effects; this.gameState.nextLevelObstacles = obstacles; this.gameState.showLevelPreview = true; this.render(); return; } const effects = this.gameState.nextLevelEffects.length > 0 ? this.gameState.nextLevelEffects : this.getEffectsForLevel(this.gameState.currentLevel); const obstacles = this.gameState.nextLevelObstacles.length > 0 ? this.gameState.nextLevelObstacles : this.getObstaclesForLevel(this.gameState.currentLevel); this.gameState = { ...this.gameState, phase: 'playing', board: Array(25).fill(null), currentEffect: effects[0] || null, currentObstacle: obstacles[0] || null, nextLevelEffects: [], nextLevelObstacles: [], showLevelPreview: false, winningLine: null, dimmedCells: [], wildCells: [], linesCompleted: 0, streakCount: 0, firstMoveWasCenter: false }; this.initializeEffect(); this.render(); } makeMove(cellIndex) { if (this.gameState.phase !== 'playing' || this.gameState.board[cellIndex] !== null || this.gameState.wildCells.includes(cellIndex)) return; this.playClick(); const newBoard = [...this.gameState.board]; newBoard[cellIndex] = 'X'; const newWinningLines = this.checkNewWinningLines(newBoard, 'X', cellIndex, this.gameState.wildCells); let scoreIncrease = 0; let newWinningLine = this.gameState.winningLine; let newLinesCompleted = this.gameState.linesCompleted; let newStreakCount = this.gameState.streakCount; if (newWinningLines.length > 0) { scoreIncrease = newWinningLines.length * 1000; if (newWinningLines.length >= 2) scoreIncrease += 500; for (const line of newWinningLines) { const effectBonus = this.processEffect(cellIndex, line); scoreIncrease += effectBonus; } newWinningLine = newWinningLines[0]; newLinesCompleted += newWinningLines.length; newStreakCount += 1; } else { newStreakCount = 0; const effectBonus = this.processEffect(cellIndex, null); scoreIncrease += effectBonus; } const isComplete = this.isBoardFull(newBoard, this.gameState.wildCells); this.gameState = { ...this.gameState, board: newBoard, score: this.gameState.score + scoreIncrease, winningLine: newWinningLine, linesCompleted: newLinesCompleted, streakCount: newStreakCount, phase: isComplete ? 'level_complete' : 'playing' }; if (cellIndex === 12 && !this.gameState.firstMoveWasCenter) { this.gameState.firstMoveWasCenter = true; } this.render(); if (!isComplete) { setTimeout(() => this.makeAIMove(), 1000); } } makeAIMove() { const emptyCells = this.getEmptyCells(this.gameState.board, this.gameState.wildCells); if (emptyCells.length === 0) return; const aiMoveIndex = emptyCells[Math.floor(Math.random() * emptyCells.length)]; this.playClick(); const newBoard = [...this.gameState.board]; newBoard[aiMoveIndex] = 'O'; const newWinningLines = this.checkNewWinningLines(newBoard, 'O', aiMoveIndex, this.gameState.wildCells); let opponentScoreIncrease = 0; if (newWinningLines.length > 0) { opponentScoreIncrease = newWinningLines.length * 1000; if (newWinningLines.length >= 2) opponentScoreIncrease += 500; } const isComplete = this.isBoardFull(newBoard, this.gameState.wildCells); this.gameState = { ...this.gameState, board: newBoard, opponentScore: this.gameState.opponentScore + opponentScoreIncrease, phase: isComplete ? 'level_complete' : 'playing' }; this.render(); } nextLevel() { this.gameState.currentLevel++; const effects = this.getEffectsForLevel(this.gameState.currentLevel); const obstacles = this.getObstaclesForLevel(this.gameState.currentLevel); this.gameState.nextLevelEffects = effects; this.gameState.nextLevelObstacles = obstacles; this.gameState.showLevelPreview = true; this.gameState.phase = 'menu'; this.render(); } toggleMute() { this.isMuted = !this.isMuted; this.render(); } render() { const app = document.getElementById('app'); app.innerHTML = this.getHTML(); this.attachEventListeners(); } getHTML() { if (this.gameState.phase === 'menu' && !this.gameState.showLevelPreview) { return `<div class='menu-screen'><h1>TicTacPro</h1><p>Enhanced 5x5 Tic-Tac-Toe with 24 effects and 9 obstacles</p><button class='start-button' onclick='game.startGame()'>Start Game</button></div>`; } if (this.gameState.phase === 'menu' && this.gameState.showLevelPreview) { return `<div class='level-preview-screen'><h2>NEXT ROUND</h2><div class='level-info'><div class='level-display'><div class='level-number'>${this.gameState.currentLevel}</div></div></div><div class='effects-preview'>${this.gameState.nextLevelEffects.map(effect => `<div class='effect-preview good-effect'><h3>${effect.name}</h3><p>${effect.text}</p></div>`).join('')}${this.gameState.nextLevelObstacles.map(obstacle => `<div class='effect-preview bad-effect'><h3>${obstacle.name}</h3><p>${obstacle.text}</p></div>`).join('')}</div><button class='start-button' onclick='game.startGame()'>Start Level</button></div>`; } if (this.gameState.phase === 'playing') { return `<div class='game-area'><div class='game-layout'><div class='level-display'><div class='level-number'>${this.gameState.currentLevel}</div></div><div class='score-display'><div class='score-section'><div class='score-label'>Your Score</div><div class='score-value'>${this.gameState.score}</div></div><div class='score-section'><div class='score-label'>Opponent</div><div class='score-value'>${this.gameState.opponentScore}</div></div></div><div></div></div><div class='board-container'><div class='game-board'>${this.renderBoard()}</div></div></div>`; } if (this.gameState.phase === 'level_complete') { return `<div class='level-complete-screen'><h2>Level ${this.gameState.currentLevel} Complete!</h2><div class='round-scores'><p>Your Score: ${this.gameState.score}</p><p>Opponent Score: ${this.gameState.opponentScore}</p></div>${this.gameState.currentLevel < 10 ? `<button class='next-level-button' onclick='game.nextLevel()'>Next Level</button>` : `<div class='game-complete'><h2>Game Complete!</h2><button class='start-button' onclick='location.reload()'>Play Again</button></div>`}</div>`; } } renderBoard() { return this.gameState.board.map((cell, index) => { let classes = 'cell'; let content = cell || ''; if (this.gameState.dimmedCells.includes(index)) { classes += ' dimmed'; if (cell) content = '?'; } if (this.gameState.wildCells.includes(index)) { classes += ' wild'; content = 'â˜…'; } if (this.gameState.winningLine && this.gameState.winningLine.includes(index)) { classes += ' winning'; } const disabled = cell !== null || this.gameState.wildCells.includes(index); return `<div class='${classes}' onclick='${disabled ? '' : `game.makeMove(${index})`}'>${content}</div>`; }).join(''); } attachEventListeners() { const soundButtons = `<div class='sound-buttons'><div class='sound-button' onclick='game.toggleMute()' title='${this.isMuted ? 'Unmute' : 'Mute'}'>${this.isMuted ? 'ðŸ”‡' : 'ðŸ”Š'}</div></div>`; if (!document.querySelector('.sound-buttons')) { document.body.insertAdjacentHTML('beforeend', soundButtons); } } } const gameData = GAME_DATA_PLACEHOLDER; const gameJson = JSON.stringify(gameData); window.game = new TicTacPro();",

  "extractor": "// Extraction script - Run this to create the game HTML file\nfunction extractGame(jsonData) {\n  const game = typeof jsonData === 'string' ? JSON.parse(jsonData) : jsonData;\n  const js = game.javascript.replace('GAME_DATA_PLACEHOLDER', JSON.stringify(game.gameData));\n  const html = game.html.replace('GAME_CSS_PLACEHOLDER', game.css).replace('GAME_JS_PLACEHOLDER', js);\n  \n  // Create downloadable file\n  const blob = new Blob([html], { type: 'text/html' });\n  const url = URL.createObjectURL(blob);\n  const a = document.createElement('a');\n  a.href = url;\n  a.download = 'TicTacPro.html';\n  document.body.appendChild(a);\n  a.click();\n  document.body.removeChild(a);\n  URL.revokeObjectURL(url);\n}\n\n// Usage: extractGame(jsonContent);",

  "instructions": "SIMPLE USAGE: 1) Save this JSON file 2) Copy the 'extractor' code into browser console 3) Run extractGame() with this JSON 4) Opens complete playable HTML file. ALTERNATIVE: Copy the values and replace placeholders in the HTML template."
}